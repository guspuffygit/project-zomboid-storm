package io.pzstorm.storm.lua;

import static io.pzstorm.storm.logging.StormLogger.LOGGER;

import io.pzstorm.storm.core.StormPaths;
import java.io.BufferedWriter;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import se.krka.kahlua.integration.annotations.LuaMethod;
import se.krka.kahlua.vm.JavaFunction;
import se.krka.kahlua.vm.KahluaTable;
import se.krka.kahlua.vm.KahluaTableIterator;
import zombie.Lua.LuaManager;

/**
 * Generates LuaLS-compatible type stub files from the classes exposed to Lua by Project Zomboid's
 * Kahlua integration. Call {@link #generate()} after {@code Exposer.exposeAll()} has completed.
 *
 * <p>Stubs are split into one file per Java package for easier navigation.
 */
public final class LuaTypeStubGenerator {

    private static final String STUBS_DIR_NAME = "stubs";

    private static final Set<String> LUA_KEYWORDS =
            Set.of(
                    "and",
                    "break",
                    "do",
                    "else",
                    "elseif",
                    "end",
                    "false",
                    "for",
                    "function",
                    "goto",
                    "if",
                    "in",
                    "local",
                    "nil",
                    "not",
                    "or",
                    "repeat",
                    "return",
                    "then",
                    "true",
                    "until",
                    "while");

    private static int skippedClasses;

    private LuaTypeStubGenerator() {}

    @SuppressWarnings("unchecked")
    public static void generate() {
        try {
            LOGGER.info("[LuaTypeStubGenerator] Starting LuaLS stub generation...");

            LuaManager.Exposer exposer = LuaManager.exposer;
            if (exposer == null) {
                LOGGER.error("[LuaTypeStubGenerator] LuaManager.exposer is null — aborting.");
                return;
            }

            java.lang.reflect.Field exposedField =
                    LuaManager.Exposer.class.getDeclaredField("exposed");
            exposedField.setAccessible(true);
            Set<Class<?>> exposedClasses = (Set<Class<?>>) exposedField.get(exposer);

            if (exposedClasses == null || exposedClasses.isEmpty()) {
                LOGGER.warn("[LuaTypeStubGenerator] No exposed classes found.");
                return;
            }

            Set<Class<?>> allClasses = new LinkedHashSet<>();
            for (Class<?> clazz : exposedClasses) {
                collectClassHierarchy(clazz, allClasses, exposer);
            }

            LOGGER.info(
                    "[LuaTypeStubGenerator] Collected {} classes from exposer", allClasses.size());

            Path outDir = StormPaths.getStormDataDirectory().toPath().resolve(STUBS_DIR_NAME);
            deleteDirectoryRecursively(outDir);
            Files.createDirectories(outDir);

            // --- Group classes by package and write one file per package ---

            skippedClasses = 0;
            Map<String, List<Class<?>>> classesByPackage = new TreeMap<>();
            for (Class<?> clazz : allClasses) {
                String pkg;
                try {
                    Package p = clazz.getPackage();
                    pkg = (p != null) ? p.getName() : "_default";
                } catch (Throwable t) {
                    pkg = "_default";
                }
                classesByPackage.computeIfAbsent(pkg, k -> new ArrayList<>()).add(clazz);
            }

            // Sort classes within each package by name for deterministic output
            for (List<Class<?>> classes : classesByPackage.values()) {
                classes.sort(Comparator.comparing(Class::getName));
            }

            int fileCount = 0;
            for (Map.Entry<String, List<Class<?>>> entry : classesByPackage.entrySet()) {
                String pkg = entry.getKey();
                List<Class<?>> classes = entry.getValue();
                String fileName = pkg.replace('.', '_') + ".lua";
                Path outFile = outDir.resolve(fileName);

                try (BufferedWriter w = Files.newBufferedWriter(outFile)) {
                    w.write("--- @meta\n");
                    w.write("--- Stubs for package: " + pkg + " (auto-generated by Storm)\n\n");

                    for (Class<?> clazz : classes) {
                        try {
                            writeClassStub(w, clazz);
                        } catch (Throwable t) {
                            skippedClasses++;
                        }
                    }
                }
                fileCount++;
            }

            if (skippedClasses > 0) {
                LOGGER.warn(
                        "[LuaTypeStubGenerator] Skipped {} classes due to reflection errors",
                        skippedClasses);
            }
            LOGGER.info("[LuaTypeStubGenerator] Wrote {} package stub files", fileCount);

            // --- Global function stubs ---

            Set<String> coveredNames = new HashSet<>();

            for (Class<?> clazz : allClasses) {
                try {
                    String name = clazz.getSimpleName().replace('$', '_');
                    if (!name.isEmpty()) coveredNames.add(name);
                } catch (Throwable t) {
                    // skip
                }
            }

            Path globalStubFile = outDir.resolve("pz_globals.lua");
            try (BufferedWriter w = Files.newBufferedWriter(globalStubFile)) {
                w.write("--- @meta\n");
                w.write(
                        "--- Project Zomboid global Lua function stubs (auto-generated by Storm)\n\n");

                writeGlobalFunctions(w, coveredNames);
            }

            // --- Environment globals (Events, Hook, CoopServer, etc.) ---

            KahluaTable env = LuaManager.env;
            if (env != null) {
                Path envStubFile = outDir.resolve("pz_environment.lua");
                try (BufferedWriter w = Files.newBufferedWriter(envStubFile)) {
                    w.write("--- @meta\n");
                    w.write(
                            "--- Lua environment globals not covered by class/function stubs"
                                    + " (auto-generated by Storm)\n\n");

                    writeEnvironmentGlobals(w, env, coveredNames);
                }
            } else {
                LOGGER.warn(
                        "[LuaTypeStubGenerator] LuaManager.env is null — skipping environment scan");
            }

            LOGGER.info(
                    "[LuaTypeStubGenerator] Done. Wrote {} class stubs + globals + environment to '{}'",
                    allClasses.size(),
                    outDir.toAbsolutePath());

        } catch (Exception e) {
            LOGGER.error("[LuaTypeStubGenerator] Failed to generate stubs", e);
        }
    }

    private static void collectClassHierarchy(
            Class<?> clazz, Set<Class<?>> out, LuaManager.Exposer exposer) {
        if (clazz == null || clazz == Object.class || out.contains(clazz)) return;
        if (!exposer.shouldExpose(clazz)) return;
        out.add(clazz);
        collectClassHierarchy(clazz.getSuperclass(), out, exposer);
        for (Class<?> iface : clazz.getInterfaces()) {
            collectClassHierarchy(iface, out, exposer);
        }
    }

    private static void writeClassStub(BufferedWriter w, Class<?> clazz) throws IOException {
        String simpleName;
        try {
            simpleName = clazz.getSimpleName().replace('$', '_');
        } catch (Throwable t) {
            skippedClasses++;
            return;
        }
        if (simpleName.isEmpty()) return;

        Class<?> superClass = clazz.getSuperclass();
        if (superClass != null && superClass != Object.class) {
            w.write("---@class " + simpleName + " : " + toLuaType(superClass) + "\n");
        } else {
            w.write("---@class " + simpleName + "\n");
        }

        Field[] fields = getSafeFields(clazz);
        Arrays.sort(fields, Comparator.comparing(Field::getName));
        for (Field field : fields) {
            try {
                int mods = field.getModifiers();
                if (Modifier.isPublic(mods) && Modifier.isStatic(mods)) {
                    String fieldName = field.getName();
                    if (LUA_KEYWORDS.contains(fieldName)) fieldName += "_";
                    w.write("---@field " + fieldName + " " + toLuaType(field.getType()) + "\n");
                }
            } catch (Throwable t) {
                // skip fields that can't be reflected
            }
        }

        w.write(simpleName + " = {}\n\n");

        Constructor<?>[] ctors = getSafeConstructors(clazz);
        Arrays.sort(
                ctors,
                Comparator.comparingInt(Constructor<?>::getParameterCount)
                        .thenComparing(LuaTypeStubGenerator::constructorSignatureKey));
        for (Constructor<?> ctor : ctors) {
            try {
                if (!Modifier.isPublic(ctor.getModifiers())) continue;
                writeConstructor(w, simpleName, ctor);
            } catch (Throwable t) {
                // skip constructors that can't be reflected
            }
        }

        Method[] methods = getSafeMethods(clazz);
        Arrays.sort(
                methods,
                Comparator.comparing(Method::getName)
                        .thenComparing(LuaTypeStubGenerator::methodSignatureKey));
        Set<String> writtenMethods = new HashSet<>();
        for (Method method : methods) {
            try {
                if (!Modifier.isPublic(method.getModifiers())) continue;
                if (method.isBridge()) continue;
                if (isObjectMethod(method)) continue;

                String sig = methodSignatureKey(method);
                if (!writtenMethods.add(sig)) continue;

                writeMethod(w, simpleName, method, Modifier.isStatic(method.getModifiers()));
            } catch (Throwable t) {
                // skip methods that can't be reflected
            }
        }

        w.write("\n");
    }

    private static void writeConstructor(BufferedWriter w, String className, Constructor<?> ctor)
            throws IOException {
        Parameter[] params = ctor.getParameters();
        for (Parameter p : params) {
            w.write(
                    "---@param "
                            + sanitizeParamName(p.getName())
                            + " "
                            + toLuaType(p.getType())
                            + "\n");
        }
        w.write("---@return " + className + "\n");
        w.write("function " + className + ".new(");
        writeParamList(w, params);
        w.write(") end\n\n");
    }

    private static void writeMethod(
            BufferedWriter w, String className, Method method, boolean isStatic)
            throws IOException {
        Parameter[] params = method.getParameters();
        for (Parameter p : params) {
            w.write(
                    "---@param "
                            + sanitizeParamName(p.getName())
                            + " "
                            + toLuaType(p.getType())
                            + "\n");
        }

        Class<?> returnType = method.getReturnType();
        if (returnType != void.class && returnType != Void.class) {
            w.write("---@return " + toLuaType(returnType) + "\n");
        }

        String methodName = method.getName();
        if (LUA_KEYWORDS.contains(methodName)) methodName += "_";

        w.write("function " + className + (isStatic ? "." : ":") + methodName + "(");
        writeParamList(w, params);
        w.write(") end\n\n");
    }

    private static void writeParamList(BufferedWriter w, Parameter[] params) throws IOException {
        for (int i = 0; i < params.length; i++) {
            if (i > 0) w.write(", ");
            w.write(sanitizeParamName(params[i].getName()));
        }
    }

    private static void writeGlobalFunctions(BufferedWriter w, Set<String> coveredNames)
            throws IOException {
        int globalCount = 0;
        Method[] globalMethods = LuaManager.GlobalObject.class.getMethods();
        Arrays.sort(
                globalMethods,
                Comparator.comparing(Method::getName)
                        .thenComparing(LuaTypeStubGenerator::methodSignatureKey));
        for (Method method : globalMethods) {
            try {
                LuaMethod ann = method.getAnnotation(LuaMethod.class);
                if (ann == null || !ann.global()) continue;

                String luaName = ann.name().isEmpty() ? method.getName() : ann.name();
                coveredNames.add(luaName);

                Parameter[] params = method.getParameters();
                for (Parameter p : params) {
                    w.write(
                            "---@param "
                                    + sanitizeParamName(p.getName())
                                    + " "
                                    + toLuaType(p.getType())
                                    + "\n");
                }

                Class<?> returnType = method.getReturnType();
                if (returnType != void.class && returnType != Void.class) {
                    w.write("---@return " + toLuaType(returnType) + "\n");
                }

                w.write("function " + luaName + "(");
                writeParamList(w, params);
                w.write(") end\n\n");
                globalCount++;
            } catch (Throwable t) {
                // skip methods that can't be reflected
            }
        }
        LOGGER.info("[LuaTypeStubGenerator] Wrote {} global function stubs", globalCount);
    }

    private static void writeEnvironmentGlobals(
            BufferedWriter w, KahluaTable env, Set<String> coveredNames) throws IOException {
        // Collect and sort entries for deterministic output
        Map<String, Object> sorted = collectTableEntries(env);

        int envCount = 0;
        for (Map.Entry<String, Object> e : sorted.entrySet()) {
            String name = e.getKey();
            Object value = e.getValue();

            // Skip anything already covered by class stubs or global function stubs
            if (coveredNames.contains(name)) continue;

            // Skip Lua standard library names and internal keys
            if (isStandardLuaGlobal(name)) continue;

            try {
                if (value instanceof KahluaTable) {
                    writeTableStub(w, name, (KahluaTable) value, 0);
                    envCount++;
                } else if (value instanceof JavaFunction) {
                    w.write("---@param ... any\n");
                    w.write("---@return any\n");
                    w.write("function " + name + "(...) end\n\n");
                    envCount++;
                } else if (value instanceof Double) {
                    w.write("---@type number\n");
                    w.write(name + " = " + value + "\n\n");
                    envCount++;
                } else if (value instanceof String) {
                    w.write("---@type string\n");
                    w.write(name + " = \"\"\n\n");
                    envCount++;
                } else if (value instanceof Boolean) {
                    w.write("---@type boolean\n");
                    w.write(name + " = " + value + "\n\n");
                    envCount++;
                } else if (value != null) {
                    // Java object exposed directly — use its class name
                    w.write("---@type " + toLuaType(value.getClass()) + "\n");
                    w.write(name + " = nil\n\n");
                    envCount++;
                }
            } catch (Throwable t) {
                LOGGER.debug(
                        "[LuaTypeStubGenerator] Failed to write env global '{}': {}",
                        name,
                        t.getMessage());
            }
        }
        LOGGER.info("[LuaTypeStubGenerator] Wrote {} environment global stubs", envCount);
    }

    private static void writeTableStub(
            BufferedWriter w, String tableName, KahluaTable table, int depth) throws IOException {
        // Guard against excessively deep or circular references
        if (depth > 3) {
            w.write("---@type table\n");
            w.write(tableName + " = {}\n\n");
            return;
        }

        w.write(tableName + " = {}\n\n");

        Map<String, Object> sorted = collectTableEntries(table);
        for (Map.Entry<String, Object> e : sorted.entrySet()) {
            String fieldName = e.getKey();
            Object value = e.getValue();

            // Skip metatable-style keys
            if (fieldName.startsWith("__")) continue;

            String qualifiedName = tableName + "." + fieldName;

            try {
                if (value instanceof KahluaTable) {
                    writeTableStub(w, qualifiedName, (KahluaTable) value, depth + 1);
                } else if (value instanceof JavaFunction) {
                    w.write("---@param ... any\n");
                    w.write("---@return any\n");
                    w.write("function " + qualifiedName + "(...) end\n\n");
                } else if (value instanceof Double) {
                    w.write("---@type number\n");
                    w.write(qualifiedName + " = " + value + "\n\n");
                } else if (value instanceof String) {
                    w.write("---@type string\n");
                    w.write(qualifiedName + " = \"\"\n\n");
                } else if (value instanceof Boolean) {
                    w.write("---@type boolean\n");
                    w.write(qualifiedName + " = " + value + "\n\n");
                } else if (value != null) {
                    w.write("---@type " + toLuaType(value.getClass()) + "\n");
                    w.write(qualifiedName + " = nil\n\n");
                }
            } catch (Throwable t) {
                // skip entries that fail
            }
        }
    }

    private static Map<String, Object> collectTableEntries(KahluaTable table) {
        Map<String, Object> sorted = new TreeMap<>();
        KahluaTableIterator it = table.iterator();
        while (it.advance()) {
            Object key = it.getKey();
            if (key instanceof String) {
                sorted.put((String) key, it.getValue());
            }
        }
        return sorted;
    }

    private static boolean isStandardLuaGlobal(String name) {
        switch (name) {
            case "_G":
            case "_VERSION":
            case "math":
            case "string":
            case "table":
            case "coroutine":
            case "os":
            case "io":
            case "debug":
            case "package":
            case "pcall":
            case "xpcall":
            case "print":
            case "select":
            case "type":
            case "tostring":
            case "tonumber":
            case "getmetatable":
            case "setmetatable":
            case "error":
            case "unpack":
            case "setfenv":
            case "getfenv":
            case "rawequal":
            case "rawset":
            case "rawget":
            case "rawlen":
            case "collectgarbage":
            case "require":
            case "loadstring":
            case "loadfile":
            case "loadstream":
            case "dofile":
            case "assert":
            case "ipairs":
            case "pairs":
            case "next":
            case "newrandom":
            case "array":
            case "bytecodeloader":
            case "debugstacktrace":
                return true;
            default:
                return false;
        }
    }

    private static String toLuaType(Class<?> type) {
        if (type == null) return "any";
        if (type == boolean.class || type == Boolean.class) return "boolean";
        if (type == int.class || type == Integer.class) return "integer";
        if (type == long.class || type == Long.class) return "integer";
        if (type == short.class || type == Short.class) return "integer";
        if (type == byte.class || type == Byte.class) return "integer";
        if (type == float.class || type == Float.class) return "number";
        if (type == double.class || type == Double.class) return "number";
        if (type == char.class || type == Character.class) return "string";
        if (type == String.class) return "string";
        if (type == void.class || type == Void.class) return "nil";
        if (type == Object.class) return "any";
        if (type.isArray()) {
            Class<?> comp = type.getComponentType();
            return comp != null ? toLuaType(comp) + "[]" : "any[]";
        }
        try {
            return type.getSimpleName().replace('$', '_');
        } catch (Throwable t) {
            return type.getName().replace('$', '_').replaceAll(".*\\.", "");
        }
    }

    private static String sanitizeParamName(String name) {
        if (LUA_KEYWORDS.contains(name)) return name + "_";
        return name;
    }

    private static String methodSignatureKey(Method m) {
        StringBuilder sb = new StringBuilder(m.getName());
        for (Class<?> p : m.getParameterTypes()) {
            sb.append('|').append(p.getName());
        }
        return sb.toString();
    }

    private static String constructorSignatureKey(Constructor<?> c) {
        StringBuilder sb = new StringBuilder();
        for (Class<?> p : c.getParameterTypes()) {
            sb.append('|').append(p.getName());
        }
        return sb.toString();
    }

    private static boolean isObjectMethod(Method m) {
        try {
            Object.class.getMethod(m.getName(), m.getParameterTypes());
            return true;
        } catch (NoSuchMethodException e) {
            return false;
        }
    }

    private static Field[] getSafeFields(Class<?> clazz) {
        try {
            return clazz.getFields();
        } catch (Throwable t) {
            return new Field[0];
        }
    }

    private static Method[] getSafeMethods(Class<?> clazz) {
        try {
            return clazz.getMethods();
        } catch (Throwable t) {
            return new Method[0];
        }
    }

    private static Constructor<?>[] getSafeConstructors(Class<?> clazz) {
        try {
            return clazz.getConstructors();
        } catch (Throwable t) {
            return new Constructor[0];
        }
    }

    private static void deleteDirectoryRecursively(Path dir) throws IOException {
        if (!Files.exists(dir)) return;
        Files.walkFileTree(
                dir,
                new SimpleFileVisitor<>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                            throws IOException {
                        Files.delete(file);
                        return FileVisitResult.CONTINUE;
                    }

                    @Override
                    public FileVisitResult postVisitDirectory(Path d, IOException exc)
                            throws IOException {
                        Files.delete(d);
                        return FileVisitResult.CONTINUE;
                    }
                });
    }
}
